<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ICONIX on Koyo&#39;s Blog</title>
    <link>https://www.dm-on.info/posts/modeling/iconix/</link>
    <description>Recent content in ICONIX on Koyo&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 06 Dec 2020 01:30:34 +0900</lastBuildDate><atom:link href="https://www.dm-on.info/posts/modeling/iconix/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ICONIX Process</title>
      <link>https://www.dm-on.info/posts/modeling/iconix/iconix_process/</link>
      <pubDate>Sun, 06 Dec 2020 01:30:34 +0900</pubDate>
      
      <guid>https://www.dm-on.info/posts/modeling/iconix/iconix_process/</guid>
      <description>ICONIXの分析工程 ここでは、ICONIXの分析工程を見てゆきます。最初に全てのベースとなる静的モデルのドメイン分析、続けて動的モデルのユースケース分析、ロバストネス分析、そしてシーケンス分析と進みます。この過程で、全ての主要な用語はドメイン分析で作成したドメイン用語集を元に行わなければなりません。
ドメイン用語集に「ユーザー」と定義したならば、以降の分析に出てくる用語は「利用者」ではなく「ユーザー」なのです。「利用者」の方が適切だと思ったのならば、まずドメイン用語集を直さなければなりません。では、最初にそのドメイン分析から入りたいと思います。
ドメイン分析 ドメイン用語集は全ての工程の基本です。フワフワとした曖昧な言葉を棄て、正確で本質的な用語を捉えてゆくと、思考がクリアになります。また、ドメイン用語は属性も定義しますので、「ユーザー」と定義した際に「ユーザーID」や「氏名」「住所」等が含まれているのか否かも明確になります。
仮に「ユーザーID」や「氏名」「住所」等が含まれていた場合は、会話の中で「ユーザーを渡し…」といった場合にこれらの情報も付随することが分かるわけです。厳密さだけではなく簡潔さも手に入れる事ができます。会話と文書が徐々に変わってゆくのが体験できるかも知れません。
 ドメイン分析を行うには、最初にドメイン用語の候補を抽出します。これはドメインエキスパートが提供するユーザーストーリー等から導き出します。何やら難しそうに聞こえますが、ドメインエキスパートというのは業務に詳しい担当者、ユーザーストーリーとは業務の流れを説明した文章です。簡単に説明すると「お話を聞いたり文章を読んだりしてキーワードを見つける」という作業に過ぎません。
一通りドメイン用語が洗い出せたなら、次に用語同士の関連を洗い出します。最初に単純な線で関連を引いてみましょう。ここで注意するのは、厳密に定義しすぎると多くの用語同士に線が引かれてゴチャついてくる事態です。原則としてドメイン分析はモデリング作業なので、全て正確に洗い出すというより「大事な部分を強調し細かい部分は無視する」というスタンスが重要です。余計な部分を削ぎ落としてこそ大事な部分が目立つからです。
用語間に線を引き終えたら、次に線を三種類に分類しましょう。「関連」「汎化」「集約」の関係に大きく分類できれば良いと思います。
   # 項目 説明     1 関連 用語同士の対等な関係です。AはBを使う、AがBを生成する、AはBを参照する…等です   2 汎化 用語同士の抽象的な関係です。&amp;ldquo;is a&amp;rdquo; とも表現され「課金ユーザー」は「ユーザ」を継承する…等です   3 集約 用語同士の構造的な関係です。&amp;ldquo;has a&amp;rdquo; とも表現され「エンジン」は「バイク」に含まれる…等です     一旦大きく分類が出来たら、次に関連を詳細化しましょう。
   # 項目 説明     1 関連 用語同士の関連に名前をつけ、関連が片方向のものであれば関連線を矢印(→)に変更します   2 汎化 汎化関係を「汎化」と「実現」に細かく分類します   3 集約 集約関係を「集約」と「コンポジション」に細かく分類します     関連の詳細化が終わったら、汎化(実現) 以外の関連に数的な関係を定義します。例えば「バイク」と「エンジン」の数的関係は 1:1 です。最大300人が入れる映画館とお客さんの数的関係は 1:0.</description>
    </item>
    
    <item>
      <title>ICONIX</title>
      <link>https://www.dm-on.info/posts/modeling/iconix/iconix/</link>
      <pubDate>Thu, 03 Dec 2020 00:09:57 +0900</pubDate>
      
      <guid>https://www.dm-on.info/posts/modeling/iconix/iconix/</guid>
      <description>ICONIX概要 ICONIXとは、ユースケース駆動開発の手法の一つです。決して最近の技法ではなくUMLが登場した頃に誕生した手法ですが、本質的でスモールセットな側面も相まって、今日でも依然として有用な手法となっています。
ICONIXの特徴は、ざっと纏めると以下の様になります。
 ユースケース駆動で、ロバストネス図、シーケンス図へと動的モデルを詳細化すること 動的モデル導出の過程でクラス図の静的モデルを導出すること 分析過程でこれら動的側面と静的側面を突き合わせ検証と洗練を繰り返すこと 純粋なUMLに加えロバストネス図を活用し動的モデルのミッシング・リンクを補完すること  ICONIXの利点 用語定義 ICONIXを適用すると何が良いのでしょうか。まず第一に用語が洗練されます。用語の整理は一般的には用語集等を作成しますが、ここでの付加価値は用語の定義の厳密化だけです。多くの場合、用語自体には何の検証も入りません。ICONIXの場合は、プロセス全体を通じて用語を検証します。ここで検証された用語は以下に提示される厳密さを持ちます。
   # 項目 説明     1 名称 用語の名称です。利用局面の想定して検証し抽象度や観点を検討しています   2 関連 用語間の関連です。用語同士の関連が明確になります   3 数的関連 用語間の数的関連です。1:1の関係にあるのか1:Nの関係にあるのかが瞭然です   4 関連の方向 用語の関連の方向性です。一方的な関連なのか双方的な関連なのかも見分けられます   5 関連の抽象関係 用語同士の抽象関係です。抽象化した用語や具象化した用語を確認できます   6 関連の保有関係 用語同士の保有・包含関係です。用語の構造が明確化されます   7 属性 用語が含む属性情報です。用語一つでどれだけの情報を保持しているかが明確になります   8 操作 用語が実行可能な操作です。用語の振る舞いを明示し責務を確認することができます      これだけ分析されているのであれば、一般的な用語集よりはるかに明確に分析できている分かると思います。一方で、この全て分析するのは相当骨が折れるのではという懸念も生じるかもしれません。確かに労力は掛かりますが、この分析は繰り返して行うため負荷は分散されます。特に最初の分析はラフなものでも構いません。むしろ最初から詳細な分析は不可能で、動的モデルの分析が進むのにつれて徐々に詳細化できてくる、というのが自然な流れです。最終的にはプログラムレベルのクラス図に近いレベルの詳細な概念モデルが醸成されます。
 厳密な動的モデル 動的モデルの分析はユースケース図・ロバストネス図・シーケンス図と詳細化されます。またそれぞれの図には明確な役割があります。簡単にまとめてみましょう。併せて、各分析過程でドメイン用語がどう洗練されるのかも提示します。
   # 項目 説明 ドメイン用語     1 ユースケース図 利用者がシステムを利用する際のユースケースを明示します。機能要件の定義に相当します 名称と各種関連   2 ロバストネス図 各ユースケースの動きを概念レベルで捉えます。画面・処理・データの相互作用を定義します。機能設計に相当します エンティティとしての属性情報   3 シーケンス図 各ロバストネス分析のコントロール処理を詳細化します。クラス毎の責務を明示化するプログラム設計に相当します 各種クラスとしての操作 (振る舞い)     こうしてみると、ラフな仮説から整合性を担保しながら詳細化してゆく、とても理に適った分析手法だということが分かるのではないかと思います。また、無駄に多くの設計書を書き上げるのではなく、最小限のUML(ロバストネス図も含む)のみで分析を進められるというのも工数的に魅力ですし、そのUMLの力を最大限に引き出して、無駄なくプログラムに落としやすい分析・設計工程が踏めるというのも魅力です。</description>
    </item>
    
  </channel>
</rss>
