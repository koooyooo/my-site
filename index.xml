<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Koyo's Blog</title><link>https://www.dm-on.info/</link><description>Recent content on Koyo's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 06 Dec 2020 01:30:34 +0900</lastBuildDate><atom:link href="https://www.dm-on.info/index.xml" rel="self" type="application/rss+xml"/><item><title>ICONIX - 1.Domain分析</title><link>https://www.dm-on.info/posts/modeling/iconix/iconix_1_domain/</link><pubDate>Sun, 06 Dec 2020 01:30:34 +0900</pubDate><guid>https://www.dm-on.info/posts/modeling/iconix/iconix_1_domain/</guid><description>ICONIXの分析工程 ここでは、ICONIXの分析工程を見てゆきます。最初に全てのベースとなる静的モデルのドメイン分析、続けて動的モデルのユースケース分析、ロバストネス分析、そしてシーケンス分析と進みます。この過程で、全ての主要な用語はドメイン分析で作成したドメイン用語集を元に行わなければなりません。
ドメイン用語集に「ユーザー」と定義したならば、以降の分析に出てくる用語は「利用者」ではなく「ユーザー」なのです。「利用者」の方が適切だと思ったのならば、まずドメイン用語集を直さなければなりません。では、最初にそのドメイン分析から入りたいと思います。
ドメイン分析 ドメイン用語集は全ての工程の基本です。フワフワとした曖昧な言葉を棄て、正確で本質的な用語を捉えてゆくと、思考がクリアになります。また、ドメイン用語は属性も定義しますので、「ユーザー」と定義した際に「ユーザーID」や「氏名」「住所」等が含まれているのか否かも明確になります。
仮に「ユーザーID」や「氏名」「住所」等が含まれていた場合は、会話の中で「ユーザーを渡し…」といった場合にこれらの情報も付随することが分かるわけです。厳密さだけではなく簡潔さも手に入れる事ができます。会話と文書が徐々に変わってゆくのが体験できるかも知れません。
Before: システムはユーザID, 氏名, 住所を画面に表示する。
After : システムはユーザー情報を画面に表示する。
ドメイン分析を行うには、最初にドメイン用語の候補を抽出します。これはドメインエキスパートが提供するユーザーストーリー等から導き出します。何やら難しそうに聞こえますが、ドメインエキスパートというのは業務に詳しい担当者、ユーザーストーリーとは業務の流れを説明した文章です。簡単に説明すると「お話を聞いたり文章を読んだりしてキーワードを見つける」という作業に過ぎません。
一通りドメイン用語が洗い出せたなら、次に用語同士の関連を洗い出します。最初に単純な線で関連を引いてみましょう。ここで注意するのは、厳密に定義しすぎると多くの用語同士に線が引かれてゴチャついてくる事態です。原則としてドメイン分析はモデリング作業なので、全て正確に洗い出すというより「大事な部分を強調し細かい部分は無視する」というスタンスが重要です。余計な部分を削ぎ落としてこそ大事な部分が目立つからです。
用語間に線を引き終えたら、次に線を三種類に分類しましょう。「関連」「汎化」「集約」の関係に大きく分類できれば良いと思います。
# 項目 説明 1 関連 用語同士の一般的な関係です。&amp;ldquo;has a&amp;quot;とも表現され、一定期間相手の参照を持ちそれを使用します。AはBを使う、AはBを生成する…等です。 2 汎化 用語同士の継承関係です。&amp;ldquo;is a&amp;rdquo; とも表現され「課金ユーザー」は「ユーザ」の性質を継承する…等です 3 集約 用語同士の保有関係です。&amp;ldquo;owns a&amp;rdquo; とも表現され「バイク」は「エンジン」を保有する…等です   一旦大きく分類が出来たら、次に関連を詳細化しましょう。
# 項目 説明 1 関連 用語同士の関連に名前をつけ、関連が片方向のものであれば関連線を矢印(&amp;lt;&amp;mdash;)に変更します 2 汎化 汎化関係を「汎化」(&amp;lt;I&amp;mdash;)と「実現」(&amp;lt;I&amp;hellip;)に細かく分類します 3 集約 集約関係を「集約」(◇&amp;mdash;)と「コンポジション」(◆&amp;mdash;)に細かく分類します  例えば、AがBを暫く利用しているだけの関係で、BがAを利用することがなければ関連線に方向 (誘導可能性) を持たせます。関連線が矢印になっていない場合は暗黙的に双方向の関連を意味します(またはラフに関連を引いただけかも知れません)。矢印で線が破線の場合は、ごく一時的な利用関係を意味し依存と呼びます。関連としては特に弱いものです。</description></item><item><title>ICONIX</title><link>https://www.dm-on.info/posts/modeling/iconix/iconix/</link><pubDate>Thu, 03 Dec 2020 00:09:57 +0900</pubDate><guid>https://www.dm-on.info/posts/modeling/iconix/iconix/</guid><description>ICONIX概要 ICONIXとは、ユースケース駆動開発の手法の一つです。決して最近の技法ではなくUMLが登場した頃に誕生した手法ですが、本質的でスモールセットな側面も相まって、今日でも依然として有用な手法となっています。
ICONIXの特徴は、ざっと纏めると以下の様になります。
ユースケース駆動で、ロバストネス図、シーケンス図へと動的モデルを詳細化すること 動的モデル導出の過程でクラス図の静的モデルを導出すること 分析過程でこれら動的側面と静的側面を突き合わせ検証と洗練を繰り返すこと 純粋なUMLに加えロバストネス図を活用し動的モデルのミッシング・リンクを補完すること ICONIXの利点 厳密な用語定義 ICONIXを適用すると何が良いのでしょうか。まず第一に用語が洗練されます。用語の整理は一般的には用語集等を作成しますが、ここでの付加価値は用語の定義の厳密化だけです。多くの場合、用語自体には何の検証も入りません。ICONIXの場合は、プロセス全体を通じて用語を検証します。ここで検証された用語は以下に提示される厳密さを持ちます。
# 項目 説明 1 名称 用語の名称です。利用局面の想定して検証し抽象度や観点を検討しています 2 関連 用語間の関連です。用語同士の関連が明確になります 3 数的関連 用語間の数的関連です。1:1の関係にあるのか1:Nの関係にあるのかが瞭然です 4 関連の方向 用語の関連の方向性です。一方的な関連なのか双方的な関連なのかも見分けられます 5 関連の抽象関係 用語同士の抽象関係です。抽象化した用語や具象化した用語を確認できます 6 関連の保有関係 用語同士の保有・包含関係です。用語の構造が明確化されます 7 属性 用語が含む属性情報です。用語一つでどれだけの情報を保持しているかが明確になります 8 操作 用語が実行可能な操作です。用語の振る舞いを明示し責務を確認することができます   これだけ分析されているのであれば、一般的な用語集よりはるかに明確に分析できている分かると思います。一方で、この全て分析するのは相当骨が折れるのではという懸念も生じるかもしれません。確かに労力は掛かりますが、この分析は繰り返して行うため負荷は分散されます。特に最初の分析はラフなものでも構いません。むしろ最初から詳細な分析は不可能で、動的モデルの分析が進むのにつれて徐々に詳細化できてくる、というのが自然な流れです。最終的にはプログラムレベルのクラス図に近いレベルの詳細な概念モデルが醸成されます。
詳細化可能な動的モデル 動的モデルの分析はユースケース図・ロバストネス図・シーケンス図と詳細化されます。またそれぞれの図には明確な役割があります。簡単にまとめてみましょう。併せて、各分析過程でドメイン用語がどう洗練されるのかも提示します。
# 項目 説明 ドメイン用語 1 ユースケース図 利用者がシステムを利用する際のユースケースを明示します。機能要件の定義に相当します 名称と各種関連 2 ロバストネス図 各ユースケースの動きを概念レベルで捉えます。画面・処理・データの相互作用を定義します。機能設計に相当します エンティティとしての属性情報 3 シーケンス図 各ロバストネス分析のコントロール処理を詳細化します。クラス毎の責務を明示化するプログラム設計に相当します 各種クラスとしての操作 (振る舞い)  こうしてみると、ラフな仮説から整合性を担保しながら詳細化してゆく、とても理に適った分析手法だということが分かるのではないかと思います。また、無駄に多くの設計書を書き上げるのではなく、最小限のUML(ロバストネス図も含む)のみで分析を進められるというのも工数的に魅力ですし、そのUMLの力を最大限に引き出して、無駄なくプログラムに落としやすい分析・設計工程が踏めるというのも魅力です。</description></item><item><title>Hugo Gcs</title><link>https://www.dm-on.info/posts/site/hugo/hugo-gcs/</link><pubDate>Sun, 29 Nov 2020 22:44:51 +0900</pubDate><guid>https://www.dm-on.info/posts/site/hugo/hugo-gcs/</guid><description>ローカル起動 Hugo ローカルサーバの起動は非常に簡単で、以下のコマンドを実行するだけです。規定のポートは1313であるため http://localhost:1313にアクセスすれば編集中のサイトをリアルタイムに閲覧することができます。エディタで編集中の文書を保存すれば閲覧中のページがリロードなしで更新されます (データバインディング)。
$ hugo serve -D 静的コンテンツ生成 生成 また、サーバー機能は不要なので生成されたWebコンテンツだけが欲しいという場合もあると思います。その場合は以下のコマンドを入力することで、直下の publicディレクトリ配下にHTML等のWebコンテンツが出力されます。
$ hugo 提供 例えば、この状態でpublicディレクトリをマウントさせた Nginxを起動させれば http://localhost:80 でコンテンツを提供することができます。
$ docker run -p 80:80 -v $(pwd)/public:/usr/share/nginx/html nginx これを利用して、以下の様な Dockerfileを用意し DockerImage内にコンテンツを固めたものをDockerベースで配信というのも一つの考えです。
FROMnginx:1.19-alpineCOPY ./public /usr/share/nginx/htmlEXPOSE80CMD [&amp;#34;nginx&amp;#34;, &amp;#34;-g&amp;#34;, &amp;#34;daemon off;&amp;#34;]$ docker build -t nginx-hugo . $ docker container run --rm --name nginx-hugo -p 80:80 nginx-hugo ただ今回は、配信の度に以下の作業を行うのが少々面倒かも知れないと考え、Dockerベースの配信(当初CloudRunを想定)を止めました。とはいえ構成はシンプルなのでアイデアとしては悪くないと思います。
コンテンツの生成 イメージのビルド イメージのレジストリ登録 サービスの参照先イメージの変更 実は、Hugoのデプロイ先は、GitHubPagesが有名なのですが、今回試したら生成されたリンクのURLに問題があり(一部URL要素が重複生成された)上手くページ遷移できないという問題があったため、その他の手段を探したという経緯があります。
GCS 今回着目したのは GCS (GoogleCloudStorage) による提供です。GCSは Amazon S3の様なオブジェクトストレージで、S3同様に静的コンテンツをインターネット公開する機能も備わっています。またS3同様にランニングコストが非常に低価格です。長期的な視野で考えるとこの点は魅力です。
プロジェクト作成 GCSでのサイト管理をすると決めたら、GCPプロジェクトを作成します。GCSの世界ではプロダクト毎にプロジェクトを作成するというのがベストプラクティスになっているため、静的サイトの構築程度でも1プロジェクトを用意します。一度GCPを使った事があるのであれば決済手段の登録等が不要ですので簡易的な手続きのみで完了します。</description></item><item><title>Hugo</title><link>https://www.dm-on.info/posts/site/hugo/hugo/</link><pubDate>Sat, 28 Nov 2020 13:28:21 +0900</pubDate><guid>https://www.dm-on.info/posts/site/hugo/hugo/</guid><description>Intro Hugoでサイトを作成してみました。実際に作ってみるととても軽量なサイトになっているので驚きです。元々はWordPressでサイトを作成しようと考えていたのですが、WordPressの場合コンテンツの管理にMySQLを利用するため、維持費の面で年に1万円前後かかってしまうというのがネックでした。
また、はてなブログPro等も検討し、こちらのほうがトータルでは安価で手軽なのですが、やはり自由度の面で一定の制限が掛かってしまいます (大抵の人には十分な自由度とは思いますが)
基本的には静的コンテンツを配信するだけなので、特段リッチな基盤は必要ありません。Webサーバ上にHTMLを置くだけでも良いわけです。特に、昨今はApache,NginxベースのWebサーバを立てないでも配信する手段があります。GitHubPagesを利用しても良いですし、Amazon S3 や Google Cloud Storageといった Cloud上のストレージサービスに配信機能がありますので、その中にコンテンツを配備し設定を公開とするだけで安価に配信可能な訳です。
Hugo Hugo自体は、静的サイトジェネレーターと呼ばれるものです。静的サイトジェネレータの有名どころは Site Generators で確認できますが、Hugoは Golangでこれを実現したものとなります。多くの静的サイトジェネレータがJavaScriptを採用していますが、Golang製であるHugoは高速な処理に定評があります。
Markdown Hugoではコンテンツ(文章)をMarkdownとして記述します。 平易な記法でリッチなコンテンツを表現できるため、最近では多くのBlogサービスもMarkdown記法に対応してきていますが、Hugoを始めとした静的サイトジェネレータはMarkdownを主たる記法としてコンテンツを生成しています。
Static Site Generator 静的サイトジェネレータは「サイトは更新される回数より閲覧される回数の方が多いのだから、閲覧の度に動的なサイト生成する従来のツールは非効率だ、その代わりに更新時にサイトを生成して閲覧時には同じものを提示しよう」という発想によるものです。確かに閲覧時の処理負荷はかなり低い様で、各ページを高速に閲覧することができます。逆に、何らかの計算処理が必要な動的なページを生成しようと思ったら、静的サイトジェネレータには荷が重いということになります。</description></item></channel></rss>