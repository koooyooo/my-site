---
title: "Solid原則"
date: 2021-01-30T23:20:32+09:00
draft: false
---

## 概要

**SOLID原則** に関して個々の原則は知っているものの、全体的な関連性が分かりづらいところもあると思うので、一覧化しておきました。  
俯瞰的な観点で見ると、お互いの立ち位置や価値が確認しやすいかなと思った次第です。

### 一覧
各原則に対し、英名と和名を提示しました。次に基本的な原則と原則に基づいた実現手段を提示し、続けてその原則が影響する関係が継承関係(縦軸)なのかクラス関係(横軸)なのかを明らかにしました。更に、その実現技法が、クラス・継承・I/Fのどの分野に基づくものなのかを提示しつつ、最終目的は何なのかを改めて立ち返る形で表にしています。

| # | 英名 | 和名 | 原則と手法 | 縦軸の影響 | 横軸の影響 | クラスの技法 | 継承の技法 | I/Fの技法 | 最終目的 |
| --- | --- | --- | --- | --- | --- |--- | -- | -- | --- |
| 1 | Single<br> Responsibility<br> Principle | 単一責任の原則 | - "**クラス変更する理由は1つ以上存在してはならない**"<br>⇒ 責務に基づいたモジュール単位での処理分割 | ○<br>(階層による責務分離) | ○<br>(境界による責務分離) | ○ | △ | - | **保守性の高いロジック配置**<br>- 保守スコープの最小化<br>&nbsp;&nbsp;(責務の明示化で実現)<br> - 保守スコープ内の単純化<br>&nbsp;&nbsp;(責務の限定化で実現) |
| 2 | Open<br> Closed<br> Principle | 開放閉鎖原則 | - "**クラスは拡張に対して開いていなければならず 修正に対して閉じていなければならない**"<br>⇒ **継承**による拡張元クラスの変更なき拡張<br>⇒ **カプセル化**による利用側クラスへの変更なき修正 | ○ <br>(継承元を保全しつつ **Open**)| -<br> (カプセル化による **Close**)| ○ | ○ | - | **ロジック更新時のデグレ抑止**<br>- 拡張時のデグレ抑止<br>- 修正時のデグレ抑止 | 
| 3 | Liskov<br> Substitution<br> Principle | リスコフの置換原則 | - "**T型のオブジェクトxに関して真となる属性をq(x)とすると 派生型Sのオブジェクトyについて q(y) が真となる**"<br>⇒ 事前条件を強めない実装 (利用時の仕様を保証)<br>⇒ 事後条件を弱めない実装 (利用時の結果を保証) | ○ <br>(互換性を提供) | - <br>(互換性を享受) | - | ○ | - | **継承利用時の互換性保証**<br>置換された箇所における<br>- 仕様互換の保証<br>- 動作互換の保証 |
| 4 | Interface<br> Segregation<br> Principle | インターフェイス<br>分離の原則 | - "**クライアントは利用しないメソッドへの依存を強制されない**"<br>⇒ インターフェイスが強制するメソッドの最小化 | ○<br>(実現の最適化) | - | - | - | ○ | **インターフェイス実装の最適化 (縦方向)**<br>- 実装コストの最小化<br>- 再利用性の向上 |
| 5 | Dependency<br> Inversion<br> Principle | 依存性逆転の原則 | - "**上位レベルのモジュールは下位レベルのモジュールに依存すべきではない。両方とも抽象に依存すべきである**"<br>- "**抽象は詳細に依存してはならない。詳細が抽象に依存すべきである**"<br>⇒ 下位モジュールの型を抽象化し具象を隠蔽<br>⇒ 下位モジュールの生成ロジックを分離して具象を隠蔽 | ○<br>(依存先としての具象クラス準備) | -<br>(抽象化による具象クラス隠蔽)<br>(注入による具象選定の隠蔽) | - | - | ○ | **インターフェイス間結合の疎結合化 (横方向)**<br> - 下位クラスの抽象化で実現<br>- 下位インスタンス生成過程の隠蔽化で完成 |

(○：関連あり, △：関連が薄いが無くはない, - 関連なし)

## まとめ

「SOLID原則は設計上の原則」…と単純に片付けるのは簡単ですが、それぞれの原則がどういった構造を用いてどんな価値を提供しているのかを見ると、見えてくるものもあるのかなと思います。特に、クラスレベルでの初期設計に用いる単一責任の原則を除けば、その他はすべて I/F・継承関係による形象化で隠蔽された縦軸の力で、横軸への影響度を限定するものだということが見えてくるのではないでしょうか。

この記事を通じて皆さんの理解が深まれば嬉しいです。何か間違いがあれば指摘して下さい。
