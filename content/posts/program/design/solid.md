---
title: "SOLID原則"
date: 2021-01-30T23:20:32+09:00
draft: false
---

## 概要

プログラム設計上の原則である **SOLID原則** に関する記事です。個々の原則は何となくわかるものの、それぞれが目指す目的は何か、その手段として何を試みているのか、それによってこの原則ができたのか、といったポイントは聞かれてもサッと出てこなかったりします。それは多分、まだ理解しきれていない部分があるということかなと思います。

今回はより俯瞰的な観点から、それぞれの原則の特徴や立ち位置を分析してみたいと思います。

### 一覧
実際に一覧にするとそれなりの情報量があります。一気に理解しようと思うと厳しいので、徐々に消化してください。最初に表の項目に関して簡単に説明します。

- **英名・和名**：原則の英名と和名を提示します
- **原則と手法**：基本的な原則を太字で記載し、その下に実際にどう実現するかという手法を提示します
- **クラス・継承・I/F**：原則を作り込む際に使用する抽象度を(具象クラス・継承関係・I/F実現)の3種に分類して提示します
- **縦軸の作り込み・横軸の作り込み**：原則を作り込む箇所を縦軸(クラスの継承関係)と横軸(クラスの利用関係)で提示します
- **縦軸の効果・横軸の効果**：原則の効果を縦軸(クラスの継承関係)と横軸(クラスの利用関係)で提示します
- **最終目的**：技法は手段ですが その目的は何なのかを改めて振り返ります

<!-- 作り込み・効果 -->
<!-- 効果・隠蔽度 -->

| # | 英名 | 和名 | 原則と手法 | 具象 | 継承 | 実現(I/F) | 縦軸の作り込み | 横軸の作り込み | 縦軸の効果 | 横軸の効果 | 最終目的 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | -- | -- | --- |
| 1 | Single<br> Responsibility<br> Principle | 単一責任の原則 | - "**クラス変更する理由は1つ以上存在してはならない**"<br>⇒ 責務に基づいたモジュール単位での処理分割 | ○ | △ | - | ○<br>(階層の責務分離) | ○<br>(境界の責務分離) | ○<br>(保守スコープ最小化) | ○<br>(保守スコープ最小化) | **保守性の高いロジック配置**<br>- 保守スコープの最小化<br>&nbsp;&nbsp;(責務の明示化で実現)<br> - 保守スコープ内の単純化<br>&nbsp;&nbsp;(責務の限定化で実現) |
| 2 | Open<br> Closed<br> Principle | 開放閉鎖原則 | - "**クラスは拡張に対して開いていなければならず 修正に対して閉じていなければならない**"<br>⇒ **継承**による拡張元クラスの変更なき拡張<br>⇒ **カプセル化**による利用側クラスへの変更なき修正 | ○ | ○ | - | ○<br>(拡張性を担保) | ○<br>(カプセル化を担保) | ○<br>(安全な拡張経路を**Open**)| ○<br>(内部情報を適切に**Close**)| **ロジック更新時のデグレ抑止**<br>- 拡張時のデグレ抑止<br>- 修正時のデグレ抑止 | 
| 3 | Liskov<br> Substitution<br> Principle | リスコフの置換原則 | - "**T型のオブジェクトxに関して真となる属性をq(x)とすると 派生型Sのオブジェクトyについて q(y) が真となる**"<br>⇒ 事前条件を強めない実装 (利用時の仕様を保証)<br>⇒ 事後条件を弱めない実装 (利用時の結果を保証) | - | ○ | - | ○<br>(互換性を提供)| - | - | ○ <br>(互換性を享受) | **継承利用時の互換性保証**<br>置換された箇所における<br>- 仕様互換の保証<br>- 動作互換の保証 |
| 4 | Interface<br> Segregation<br> Principle | インターフェイス<br>分離の原則 | - "**クライアントは利用しないメソッドへの依存を強制されない**"<br>⇒ インターフェイスが強制するメソッドの最小化 | - | - | ○ | ○<br>(責務を最小化) | - |○<br>(実装効率の最適化) | -<br>(通常のI/Fと同等) | **インターフェイス実装の最適化 (縦方向)**<br>- 実装コストの最小化<br>- 再利用性の向上 |
| 5 | Dependency<br> Inversion<br> Principle | 依存性逆転の原則 | - "**上位レベルのモジュールは下位レベルのモジュールに依存すべきではない。両方とも抽象に依存すべきである**"<br>- "**抽象は詳細に依存してはならない。詳細が抽象に依存すべきである**"<br>⇒ 下位モジュールの型を抽象化し具象を隠蔽<br>⇒ 下位モジュールの生成ロジックを分離して具象を隠蔽 | - | - | ○ | -<br>(通常のI/Fと同等) | △<br>(別途注入の機構を用意) | -<br>(通常のI/Fと同等) | ○<br>(注入で具象を隠蔽) | **インターフェイス間結合の疎結合化 (横方向)**<br> - 下位クラスの抽象化で実現<br>- 下位インスタンス生成過程の隠蔽化で完成 |

(○：関連あり, △：関連が薄いが無くはない, - 関連なし)

## まとめ

「SOLID原則は設計上の原則」…と単純に片付けるのは簡単ですが、それぞれの原則がどういった構造を用いてどんな価値を提供しているのかを見ると、見えてくるものもあるのかなと思います。特に、クラスレベルでの初期設計に用いる単一責任の原則を除けば、その他はすべて I/F・継承関係による形象化で隠蔽された縦軸の力で、横軸への影響度を限定するものだということが見えてくるのではないでしょうか。

この記事を通じて皆さんの理解が深まれば嬉しいです。何か間違いがあれば指摘して下さい。
