---
title: "SOLID原則"
date: 2021-01-30T23:20:32+09:00
draft: false
---

## 概要

プログラム設計上の原則である **SOLID原則** に関する記事です。個々の原則は何となくわかるものの、それぞれが目指す目的は何か、その手段として何を試みているのか、それによってこの原則ができたのか、といったポイントは聞かれてもサッと出てこなかったりします。それは多分、まだ理解しきれていない部分があるということかなと思います。

今回はより俯瞰的な観点から、それぞれの原則の特徴や立ち位置を分析してみたいと思います。

## 各技法

### Single Responsibility Principle (単一責任の原則)

> 「これはね、Webも DBも メールも 何でもこなしている便利なサーバーなんだよ。」  
> 「それって下手に触ると全部止まってしまうってことかい？」

SRPはクラスの責務を限定することで、保守の範囲を限定化するための原則です。冒頭の会話の例だと、最近ではコンテナを活用して環境を分離するのではないでしょうか。コンテナは一つのプロセスに責任を持つ存在です。一つの目的のために用意された環境なので、その目的に沿わない部品は気軽に変更・削除ができます。同じ考え方はプログラムにも適用可能です。プログラムはプロセスの構成要素ですから、責務は更に細分化されます。

情報の保持に責任を持つモデル、画面とのやり取りを制御するコントローラ、一連のビジネスロジックに責任を持つサービス、または永続データのやり取りに責任を持つリポジトリ等様々なコンポーネントに分かれます。そうして責務を適切に細分化してゆくと、クラスが負う責務は1つになり、クラスを変更する理由も１つになります。

単一の責任しか負わないクラスは**コード量が減りシンプルに**なります。これが保守をする際の**理解容易性**に繋がります。そして余計な処理が紛れていないので**他の機能への副作用なく修正**できます。これが保守をする際の**安全性**に繋がります。

こうして単一の責任だけを持ったクラスが協調して全体を構築するべきだという原則が、**単一責任の原則**となります。

#### コードサンプル
(JVM系の言語のほうが得意ですが、勉強がてらGolangで書いてみました)

##### Before
```golang
// 複数の責務を負ってしまっている状態
type Server struct {
    HTMLs   []web.HTML
    DBConn  db.Conn
    Mails   []mail.Mail
}
func (s Server) ServeWeb() error {
}
func (s Server) ServeDB() error {
}
func (s SErver) ServeMail() error {
}
```

##### After
```golang
// 共通項としてのインターフェイス
type Container interface {
    Serve() error
}

// Web特化
type WebContainer struct {
    HTMLs  []web.HTML
}
func (w WebContainer) Serve() error {
}

// DB特化
type DBContainer struct {
    DBConn  db.Conn
}
func (d DBContainer) Serve() error {
}

// Mail特化
type MailContainer struct {
    Mails  []mail.Mail
}
func (m MailContainer) Serve() error {
}

// 組み合わせて提供したい場合はこれも特化して用意
type Server struct {
    Containers []Container
}
func (s Server) Serve() {
    for _, c := range s.Containers {
      go c()
    }
}
```

### Open Closed Principle (開放閉鎖原則)

> 「このマシンは CPUもメモリもディスクも拡張可能にできているのさ。  
> 　でも箱の外側は変えるなよ？ユーザーや外部デバイスが混乱するから。」

OCPは あるクラスを拡張した際、デグレードの可能性を最小にするための原則です。

### Liskov Substitution Principle (リスコフの置換原則)

> 「こちらが私の業務を引き継ぐ方です。  
> 　皆さんからの指示は従来どおりで大丈夫です。もちろん同じ結果も保証しますよ。」

### インターフェイス分離の法則

> 「弁護士の資格と医師の資格、一緒にしたら便利な資格にならないか？」  
> 「おいおい、取得する側の立場にもなってみろよ」

### 依存性逆転の法則

> 「明日の会議には翻訳担当と議事担当が必要なんだが、誰に頼めばいい？」  
> 「心配しなくても誰かを着席して待たせておきますから、本業に集中して大丈夫ですよ」

## 一覧
実際に一覧にしてみましたが、改めて見るとそれなりに情報量があります。一気に理解しようと思うと厳しいので、徐々に消化してください。

最初に表の項目に関して簡単に説明します。

- **英名・和名**：原則の英名と和名を提示します
- **原則と実現手段**：基本的な原則を太字で記載し、その下に実際にどう実現するかという手法を提示します
- **クラス・継承・I/F**：原則を作り込む際に使用する抽象度を(具象クラス・継承関係・I/F実現)の3種に分類して提示します
- **縦軸の作り込み・横軸の作り込み**：原則を作り込む箇所を縦軸(クラスの継承関係)と横軸(クラスの利用関係)で提示します
- **縦軸の効果・横軸の効果**：原則の効果を縦軸(クラスの継承関係)と横軸(クラスの利用関係)で提示します
- **最終目的**：技法は手段ですが その目的は何なのかを改めて振り返ります

| # | 英名 | 和名 | 原則と実現手段 | 具象 | 継承 | 実現(I/F) | 縦軸の作り込み | 横軸の作り込み | 縦軸の効果 | 横軸の効果 | 最終目的 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | -- | -- | --- |
| 1 | Single<br> Responsibility<br> Principle | 単一責任の原則 | - "**クラス変更する理由は1つ以上存在してはならない**"<br>⇒ 責務に基づいたモジュール単位での処理分割 | ○ | △ | - | ○<br>(階層の責務分離) | ○<br>(境界の責務分離) | ○<br>(保守スコープ最小化) | ○<br>(保守スコープ最小化) | **保守性の高いロジック分配** |
| 2 | Open<br> Closed<br> Principle | 開放閉鎖原則 | - "**クラスは拡張に対して開いていなければならず 修正に対して閉じていなければならない**"<br>⇒ **継承**による拡張元クラスの変更なき拡張<br>⇒ **カプセル化**による利用側クラスへの変更なき修正 | ○ | ○ | - | ○<br>(拡張性を担保) | ○<br>(カプセル化を担保) | ○<br>(差分拡張を**Open**)<br>⇒ 安全な拡張 | ○<br>(過剰干渉を**Close**)<br>⇒ 安全な修正| **保守性の高いクラス構造**<br>- 拡張時<br>- 修正時 | 
| 3 | Liskov<br> Substitution<br> Principle | リスコフの置換原則 | - "**T型のオブジェクトxに関して真となる属性をq(x)とすると 派生型Sのオブジェクトyについて q(y) が真となる**"<br>⇒ 事前条件を強めない実装 (仕様互換)<br>⇒ 事後条件を弱めない実装 (結果互換) | - | ○ | - | ○<br>(互換性を提供)| - | - | ○ <br>(互換性を享受) | **継承の互換性保証**<br>- 仕様互換<br>- 動作互換 |
| 4 | Interface<br> Segregation<br> Principle | インターフェイス<br>分離の原則 | - "**クライアントは利用しないメソッドへの依存を強制されない**"<br>⇒ I/F分離により各I/Fの要求メソッドを最小化 | - | - | ○ | ○<br>(責務を最小化) | - |○<br>(実装効率の最適化) | -<br>(通常のI/Fと同等) | **インターフェイス実装時の最適化 (縦方向)**<br>- 実装コストの最適化 |
| 5 | Dependency<br> Inversion<br> Principle | 依存性逆転の原則 | - "**上位レベルのモジュールは下位レベルのモジュールに依存すべきではない。両方とも抽象に依存すべきである**"<br>- "**抽象は詳細に依存してはならない。詳細が抽象に依存すべきである**"<br>⇒ 依存方向を整理<br>⇒ 下位の型を抽象化<br>⇒ 下位のインスタンスにおける調達・設定プロセスを隠蔽 | - | - | ○ | -<br>(通常のI/Fと同等) | △<br>(別途注入の機構を用意) | -<br>(通常のI/Fと同等) | ○<br>(注入で具象を隠蔽) | **インターフェイス間の疎結合 (横方向)** |

(○：関連あり, △：関連が薄いが無くはない, - 関連なし)

## まとめ

「SOLID原則は設計上の原則」…と単純に片付けるのは簡単ですが、それぞれの原則がどういった構造を用いてどんな価値を提供しているのかを見ると、見えてくるものもあるのかなと思います。特に、クラスレベルでの初期設計に用いる単一責任の原則を除けば、その他はすべて I/F・継承関係による形象化で隠蔽された縦軸の力で、横軸への影響度を限定するものだということが見えてくるのではないでしょうか。

この記事を通じて皆さんの理解が深まれば嬉しいです。何か間違いがあれば指摘して下さい。
