---
title: "Solid原則 - OCP"
date: 2021-04-18T11:46:47+09:00
draft: false
---

**"クラスは拡張に対して開いていなければならず 修正に対して閉じていなければならない"**

> 「このマシンは CPUもメモリもディスクも拡張可能にできているのさ。  
>　それに変更がケースの内側だけなら、ユーザーや外部デバイスも気づかないだろ？」

OCPは クラスの拡張性を最大化し、デグレードのリスクを最小化するための原則です。修正が外部に影響しないようにクラス外との窓口を限定し（**Close**）、修正自体を阻害しないようにクラス内の拡張ポイントを意識して設計します（**Open**）。

## 概要
冒頭の例では、マシン（コンピュータ）を引き合いに出して説明しました。マシンは内部に多くの拡張ポイントを用意している一方で、外部との接触はPCケースによって限定され一部のボタンや端子からしかやり取りできません。

例えば、マシンのケースを開ければ HDDやメモリのスロットによりパーツの追加・交換を簡単に行うことができます。これが「**拡張に対して開かれている**」部分です。逆に、専用メモリが基盤に埋め込まれており追加・交換ができなければ「拡張に対して開かれていない」ことになります。

一方で、マシンのケース自体は**外部との接触を限定**する役割を持ちます。ケースはマザーボード等の**脆弱な内部基盤を隠蔽**し、**最小限のインターフェイスを外部に公開**します（**カプセル化**）。具体的には「電源ボタン・ディスクドライブ・USB端子・電源ソケット」という最小限の窓口のみ露出され残りはケースで覆われます。露出部分の挙動さえ担保できれば、それを利用する側に修正の影響は及びません。これが「**修正に対して閉じられている**」部分です。修正に対して閉じられていれば、デグレードの危険性や再テストの必要性を最小化できます。

## 特徴
OCPの特徴は、スコープ視点では最適化の範囲が**クラスに特化している**点です。また、この最適化が、クラスには最適な責務が割り当てられていることが前提で、その責務における変更には**継承**や**委譲**を用いて開放し、他クラスからの干渉には**カプセル化**を用いて閉鎖するという手段をとります。

## コードサンプル

Doing...
