---
title: "Solid原則 - OCP"
date: 2021-04-18T11:46:47+09:00
draft: false
---

**"クラスは拡張に対して開いていなければならず 修正に対して閉じていなければならない"**

> 「このマシンは CPUもメモリもディスクも拡張可能にできているのさ。  
>　それに変更がケースの内側だけなら、ユーザーや外部デバイスも気づかないだろ？」

OCPは クラスの拡張性を最大化し、デグレードのリスクを最小化するための原則です。修正が外部に影響しないようにクラス外との窓口を限定し（**Close**）、修正自体を阻害しないようにクラス内の拡張ポイントを意識して設計します（**Open**）。

## 概要
冒頭の例では、マシン（コンピュータ）を引き合いに出して説明しました。マシンは内部に多くの拡張ポイントを用意している一方で、外部との接触はPCケースによって限定され一部のボタンや端子からしかやり取りできません。

例えば、マシンのケースを開ければ HDDやメモリのスロットによりパーツの追加・交換を簡単に行うことができます。これが「**拡張に対して開かれている**」部分です。逆に、専用メモリが基盤に埋め込まれており追加・交換ができなければ「拡張に対して開かれていない」ことになります。

一方で、マシンのケース自体は**外部との接触を限定**する役割を持ちます。ケースはマザーボード等の**脆弱な内部基盤を隠蔽**し、**最小限のインターフェイスを外部に公開**します（**カプセル化**）。具体的には「電源ボタン・ディスクドライブ・USB端子・電源ソケット」という最小限の窓口のみ露出され残りはケースで覆われます。露出部分の挙動さえ担保できれば、それを利用する側に修正の影響は及びません。これが「**修正に対して閉じられている**」部分です。修正に対して閉じられていれば、デグレードの危険性や再テストの必要性を最小化できます。

> 修正に対して閉じられている構造は、何もマシンに限った構造ではありません。自動車や船舶等の機械製品はもちろんのこと、人間や動物の体だって修正に対しては閉じられています。ですから運転手が直接エンジンを触って始動することは不可能ですし、動物が食べ物を口を介さずに胃に押し込めることも不可能です。イグニッションキーによる始動や口で咀嚼してからの嚥下で問題ありませんし、むしろその方が便利で安全にできています。例えば、ブレーキが踏まれていなければ始動できませんし、毒草を口にした際には味覚が異常を検知してくれます。なお、これをプログラムで表現すると Setter内に Validation機能を付加した状態に相当します。

## 特徴
OCPの特徴は、スコープ視点では最適化の範囲が**クラスに特化している**点です。また、この最適化が、クラスには最適な責務が割り当てられていることが前提で、その責務における変更には**継承**や**委譲**を用いて開放し、他クラスからの干渉には**カプセル化**を用いて閉鎖するという手段をとります。

## コードサンプル
実装に話を移します。コード上での Open-Closed-Principle(開放閉鎖原則) は**継承**と**委譲**による縦方向（**自身の関連**）の**開放**と、**カプセル化**による横方向（**他者との関連**）の**閉鎖**によって実現します。縦方向と横方向と表現しているのは、一般的にクラス図上では自身の継承関係は親クラスを上方に、子クラスを下方に配置して表現するからです。

### 閉鎖
閉鎖部分は変数やメソッドの可視性で制御します。これらの可視性を **private** (Javaなら **protected**も可) にすることで外部アクセスを遮断します。こうすれば外部のクラスから変数やメソッドにアクセスされることはありません。

外部から変数へのアクセスが必要な場合は、**Getter / Setter**等の publicなアクセッサメソッドを通じてアクセスを許可します。結局はアクセスさせてしまうのであれば最初から変数を publicにするのと同じだと思われるかも知れませんが、以下の点が異なります。

- Get / Set の片系統のみ許可することができます
- アクセス時に処理を挟むことができます (以下に例を示します)
  - Set時の Validation処理で内部状態を保護することができます
  - Get / Set時に参照のコピーを取得・返却することで、参照元でのポインタ更新による影響を無効化できます

Golangにおいても閉鎖部分は変数の可視性で制御します。しかし Golangのstructは Javaのclassと異なり、struct単位での可視性を制御できません (パッケージ単位となります)。ですので 利用側とは別のパッケージを用意し、その中で可視性を **private**（Javaの package private相当）にすることで閉鎖を実現します。Golangの場合は変数名や関数名を小文字始まりにすることで可視性を privateとします。具体的には以下の様な形になります。これでパッケージの外部からはアクセスできません。

この様に、内部の状態や操作を外部から隠蔽することを **カプセル化**と呼びます。

```golang
// (変数・メソッドを privateにすることで閉鎖を実現)
type Machine struct {
	powered     bool
	cpu         CPU
	memory      Memory
	hd          HardDrive
	usbDevices  []USBDevice
	hdmiDevices []HDMIDevice

	startUp  func(*Machine) error
	shutDown func(*Machine) error
}

// マシンの電源スイッチを押下
// (閉鎖対象を守るためアクセス経路を限定)
func (m *Machine) PushPowerSwitch(d time.Duration) {
	if !m.powered {
		if err := m.startUp(m); err != nil {
			log.Fatal(err)
		}
	} else {
		if (5 * time.Second) < d {
			if err := m.shutDown(m); err != nil {
				log.Fatal(err)
			}
		}
	}
}

```

### 開放

閉鎖の対象は参照元でしたが、開放の対象はサブクラスです。そのためにはサブクラスに対する拡張ポイントの可視性を緩めなければなりません。

Javaでは開放するメソッドの可視性を**protected**します。**private**だと継承が不可能になりますし **public**では外部公開されてしまうので、一般的な拡張ポイントとしては **protected**程度が妥当です。尚、Javaには無印の**package private**も存在しますが、こちらはパッケージ内を含めて公開されてしまうので（Golangのパッケージよりも広いイメージ）クラス境界をはみ出してしまい、少し開放し過ぎです。

可視性を privateにするか、protectedにするかはサブクラスに対する開放度の差となります。すべてを開放するなら protectedを、サブクラスと言えど開放すべきでない部分は privateを選択します。将来の拡張を予測しづらければ全体的に protectedとするのも良いですし、本質的に動かない部分を明示できれるのなら、その部分を privateとします。理想を言えば TemplateMethodパターンの様に、サブクラスが拡張すべき部分を見抜き、そこだけピンポイントで protectedにする設計が美しいですが、そこまで確証を持てないのであれば全体的に protectedとしておくことで最低限 拡張の邪魔をしないことを保証できます。（ここを見誤ると修正に対して閉じられてしまうためさじ加減が重要です）

Golanでは同一パッケージ内であれば struct内の変数にアクセスできますので、変数の可視性は privateのままで良いでしょう。一方でJavaと異なり継承によるメソッドのオーバーライドができないので、修正を想定する関数はメソッドではなく struct内の関数として定義しておく必要があります。この関数の実装を入れ替えることで、継承によるオーバーライドと同じ効果を期待するわけです。

具体的には、先の Machineにおける startUp関数と, shutDown関数に注目してみてください。
```golang
type Machine struct {
	// (中略)

	startUp  func(*Machine) error
	shutDown func(*Machine) error
}
```
&nbsp;  
これらの関数を入れ替えることで、継承に頼らないでも修正が可能になります。つまり、修正に対して開かれた状態を担保できるわけです。

