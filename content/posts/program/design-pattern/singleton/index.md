---
title: "Singleton"
date: 2021-03-24T00:09:10+09:00
draft: false
---

## Singleton

### 目的
Singletonの目的は**一つだけインスタンスを生成し、それを使い回す**ことです。

> ##### OOPとインスタンス数
> オブジェクト指向（OOP）の世界では、特別な理由がない限り現実世界のモノの数と、インスタンスの数を一致させます。豚が3匹いるなら `Pig`インスタンスを 3つ生成します。同様に車が1000台なら `Car`インスタンスを1000個生成します。この理由は、複製したインスタンスの数だけ固有の情報を格納できるからです。現実世界のものが増えたのならば、それを管理するオブジェクトも同じだけ増やすのが基本です。オブジェクト指向言語が現実の世界や概念の構造を雄弁に表現できるのは、この**状態の複製**が簡単に（`new Car()` or `Car{}`）実現できるからという点が大きいのです。
>
> さて、オブジェクトと言えば状態と振る舞いを持ちます。この両者で特に大きな進化をもたらしたのはどちらでしょうか？実は、インスタンスの増加で増えるのは状態だけです。状態はクラス（struct）定義時のメソッドの宣言から変わることはありません。インスタンスが複製されてもその振る舞いが同じ様にコピーされるだけです。唯一の振る舞いの変化が許される部分は、そのインスタンスの状態に依って振る舞いが変わるロジックが定義されている時です。しかし、オブジェクト指向言語によって主役の座に位置するのが状態であることに変わりはありません。
>
> この常識を根底から覆すのが **Singleton**です。何故ならその状態を1つで良い…と言い張るのですから。しかし Singletonについて深く考察してゆくと、そこにもまた OOPの本質に迫る側面があることに気付くはずです。

一つだけインスタンスを生成してそれを使い回すと何が良いのでしょうか。すぐには思い浮かばないかも知れませんが、これが活きる局面は数多くあります。

#### 1. 数の限定（&同一性の担保）
最初に紹介するのは、本当に数が限られているものをそのとおりに表現するものです。1つしかない物を厳格に表現するなら Singletonは良い選択です。例えば日本に政府は一つしかありません。つまり以下のコードが成立します。

```golang
gov := jpgov.Instance()
```

ディズニーランド内にミッキーマウスは複数存在しないという話を聞いたことがあります。それが本当なら次のコードも成立します。
```golang
m := disney.MickyInstance()
```

次にシステム的な面で考えてみます。データベースを管理するマネージャが1つしかないのであれば、以下の表現が可能です。インスタンスは関数経由で取得しても良いですし、初期ロード時に生成しても構わないなら変数として用意しておいても良いでしょう。
```golang
// 関数で取得（実装上の選択肢は広がる）
dbMgr := database.ManagerInstance()

// 変数で取得
dbMgr := database.ManagerInstance
```

#### 2. 状態の共有
Singletonが公開されるということは、単一の状態も公開されるということです。一般的にSingletonの参照はグローバルに提供されることが多いため、どこからでもアクセス可能な単一の状態という便利なものが手に入ります。例えば、Util系のクラス（package）は振る舞いという観点で単一のものを提供しますが、Singletonでは状態という観点で単一のものが提供出来るわけです。

次の例は、**Observer**パターンで通知を行う局面です。システムの各所からこのObserverに通知が入ります。このObserverは Singletonとして常に単一のインスタンスが参照されるので情報を集中的に管理できています。各所で別々のインスタンスを生成してしまったのでは集中管理になりません。
```golang
func (s Service) report() {
  o := observer.Instance()
  o.reportAccess(1)
}
```
一つしか無いというのは、一箇所で情報を管理できるという強みがあるのです。総理大臣や大統領はいくら忙しくても2名以上にしません。責務あるインスタンスに情報を集約させるための手段としても Singletonは有効なのです。

#### 3. 参照の取得
上の例をもう少し使います。通常、Observerのインスタンスが必要なら上位の生成元から延々と引数で引き渡す必要があります。しかし、Singletonではその必要がありません。Singletonの生成部分はグローバルな関数（Javaなら staticメソッド, Golangなら グローバル関数）ですので、調達は簡単です。引数をシンプルに保てますのでその点では設計上の長所となります。

一方で、グローバルな関数に触れるというのは、その処理が副作用を持つということです。単純な長所だけではないので、この部分には気をつける必要があります。余談ですが、この解決策として**DI**（Dependency Injection: 依存性の注入）という仕組みが存在し、DIが導入の際には Singletonは DIコンテナ側で実現されます。これがSingletonの完成形かもしれません。

```golang
type Service struct {
  // 注入される依存性
  o *observer.Observer
}

func (s Service) report() {
  // 利用側から取得の責務が消滅
  s.o.reportAccess(1)
}
```
&nbsp;  
> ##### 生成と利用
> Singletonの短所として「生成過程の混在」があります。利用側からすれば、唯一のインスタンスが利用できればそれで良いのですが、それを保証するためにSingletonを利用すると Singletonへの依存が発生してしまいます。これは インスタンス生成のために Factoryメソッドを利用するとFactoryメソッドへの依存性が発生してしまうのと同様です。問題はインスタンスを利用する局面において、生成する局面を把握してしまっている点です。エリック・エヴァンスの例で説明するならば、自動車工場の責務と自動車の責務は別であるべきということなのです。これに対する少しFatな解決策が**DI**というイメージです。

<!--

例えば同一性の担保です。`Enum` の様に種別を表現するクラスの種別数とインスタンス数を一致させ正確に表現するため（同値性だけでなく同一性まで担保可能）

#### 3. 軽量化
**Flyweightパターン**の様にインスタンス生成の抑制を通じて性能を担保する仕組みを提供するため

#### 4. 
**Flyweightパターン**と似ているが、Serviceの様に 操作中心で状態を持たないインスタンスを組み合わせて提供するため (DI)

Singleton の特徴はクラス(struct)やインターフェイス同士の関連ではなく、クラス内に閉じられたパターンであるという点です。

### 概要
先に述べたように、様々な目的で活用可能なのが Singletonですが、自分で実装する機会は少ないかも知れません。
理由は言語機能的に、またはF/W的に実現されることが多いパターンであるからです。
例えば Enumは Singletonの独自実装が可能なものの、言語がサポートしている場合が多いです。
また、DIコンテナの様に内部では単一インスタンス管理をしているものの、利用側は意識せずに利用しているはずです。

とは言え、生成インスタンスの数を制限する、特にSingletonの様に単一に絞る…というテクニックは一度覚えておくと様々な局面で利用可能
となりますので、身につけておくと良いと思います。

```golang
// Singletonは唯一のインスタンスを用意し、それ以外を生成できなくするパターンです。
// そのため、唯一のインスタンスしか存在しないことを保証できます。
func TestSingleton(t *testing.T) {
	// Instance()以外で生成できない => singleton.singleton{} は不可能
	s1 := singleton.Instance()
	s2 := singleton.Instance()

	// インスタンスの内容が同じだけでなく
	assert.Equal(t, s1, s2)
	// インスタンスの実体も同じ
	assert.True(t, s1 == s2)
}

// 逆に一般的な生成パターンは、コンストラクタ関数の中でインスタンスを生成します。
// そのため、同じ値を持ちますが(同値)、参照は同じ(同一)ではありません。
func TestNonSingleton(t *testing.T) {
	s1 := non_singleton.New()
	s2 := non_singleton.New()

	// インスタンスの内容は同じだが
	assert.Equal(t, s1, s2)
	// インスタンスの実体は異なる
	assert.False(t, s1 == s2)
}
```

### 実現
以下の仕組みでこれを実現します。
- 外部からインスタンスを生成できなくする
- Javaではコンストラクタを`private`にすることで、Goではstructを(小文字で開始し)`package private`にすることで実現する
- インスタンス取得用の関数を別途用意し、そこでは常に同じインスタンスを返す様に実装する

-->
