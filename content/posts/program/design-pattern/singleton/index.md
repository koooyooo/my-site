---
title: "Singleton"
date: 2021-03-24T00:09:10+09:00
draft: true
---

## Singleton

### 目的
Singletonの目的は**一つだけインスタンスを生成し、それを使い回す**ことです。

> ##### OOPとインスタンス数
> オブジェクト指向（OOP）の世界では、特別な理由がない限り現実世界のモノの数と、インスタンスの数を一致させます。豚が3匹いるなら `Pig`インスタンスを 3つ生成します。同様に車が1000台なら `Car`インスタンスを1000個生成します。この理由は、複製したインスタンスの数だけ固有の情報を格納できるからです。現実世界のものが増えたのならば、それを管理するオブジェクトも同じだけ増やすのが基本です。オブジェクト指向言語が現実の世界や概念の構造を雄弁に表現できるのは、この**状態の複製**が簡単に（`new Car()` or `Car{}`）実現できるからという点が大きいのです。
>
> さて、オブジェクトと言えば状態と振る舞いを持ちます。この両者で特に大きな進化をもたらしたのはどちらでしょうか？実は、インスタンスの増加で増えるのは状態だけです。状態はクラス（struct）定義時のメソッドの宣言から変わることはありません。インスタンスが複製されてもその振る舞いが同じ様にコピーされるだけです。唯一の振る舞いの変化が許される部分は、そのインスタンスの状態に依って振る舞いが変わるロジックが定義されている時です。しかし、オブジェクト指向言語によって主役の座に位置するのが状態であることに変わりはありません。
>
> この常識を根底から覆すのが **Singleton**です。何故ならその状態を1つで良い…と言い張るのですから。しかし Singletonについて深く考察してゆくと、そこにもまた OOPの本質に迫る側面があることに気付くはずです。

一つだけインスタンスを生成してそれを使い回すと何が良いのでしょうか。すぐには思い浮かばないかも知れませんが、これが活きる局面は数多くあります。

#### 1. 数の限定（&同一性の担保）
最初に紹介するのは、本当に数が限られているものをそのとおりに表現するものです。
例えば、世界に1つしかない物を厳格に表現するなら Singletonは良い選択です。

例えば同一性の担保です。`Enum` の様に種別を表現するクラスの種別数とインスタンス数を一致させ正確に表現するため（同値性だけでなく同一性まで担保可能）

#### 2. 状態の共有 
(ex. `Observer.getInstance().addAccessCount(1)`)

#### 3. 軽量化
**Flyweightパターン**の様にインスタンス生成の抑制を通じて性能を担保する仕組みを提供するため

#### 4. 
**Flyweightパターン**と似ているが、Serviceの様に 操作中心で状態を持たないインスタンスを組み合わせて提供するため (DI)

Singleton の特徴はクラス(struct)やインターフェイス同士の関連ではなく、クラス内に閉じられたパターンであるという点です。

### 概要
先に述べたように、様々な目的で活用可能なのが Singletonですが、自分で実装する機会は少ないかも知れません。
理由は言語機能的に、またはF/W的に実現されることが多いパターンであるからです。
例えば Enumは Singletonの独自実装が可能なものの、言語がサポートしている場合が多いです。
また、DIコンテナの様に内部では単一インスタンス管理をしているものの、利用側は意識せずに利用しているはずです。

とは言え、生成インスタンスの数を制限する、特にSingletonの様に単一に絞る…というテクニックは一度覚えておくと様々な局面で利用可能
となりますので、身につけておくと良いと思います。

```golang
// Singletonは唯一のインスタンスを用意し、それ以外を生成できなくするパターンです。
// そのため、唯一のインスタンスしか存在しないことを保証できます。
func TestSingleton(t *testing.T) {
	// Instance()以外で生成できない => singleton.singleton{} は不可能
	s1 := singleton.Instance()
	s2 := singleton.Instance()

	// インスタンスの内容が同じだけでなく
	assert.Equal(t, s1, s2)
	// インスタンスの実体も同じ
	assert.True(t, s1 == s2)
}

// 逆に一般的な生成パターンは、コンストラクタ関数の中でインスタンスを生成します。
// そのため、同じ値を持ちますが(同値)、参照は同じ(同一)ではありません。
func TestNonSingleton(t *testing.T) {
	s1 := non_singleton.New()
	s2 := non_singleton.New()

	// インスタンスの内容は同じだが
	assert.Equal(t, s1, s2)
	// インスタンスの実体は異なる
	assert.False(t, s1 == s2)
}
```

### 実現
以下の仕組みでこれを実現します。
- 外部からインスタンスを生成できなくする
- Javaではコンストラクタを`private`にすることで、Goではstructを(小文字で開始し)`package private`にすることで実現する
- インスタンス取得用の関数を別途用意し、そこでは常に同じインスタンスを返す様に実装する

